[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About me",
    "section": "",
    "text": "Hi! My name is Admir Cesar de Oliveira Junior. I’m a mix of a biologist and a mathematician, but above all, I’m an absolute nerd. I love learning, developing, researching, and teaching.\nMy academic work focuses on theoretical and computational ecology, especially using machine learning. I also have experience as a math and biology teacher and as a data analyst/scientist. This has helped me develop expertise in programming and data analysis. Essentially, I’m able to transform large, messy datasets into valuable insights using statistical and machine learning models—and a bit of magic. I’m equally capable at extracting meaningful information with little data. I can also create beautiful visualizations to express data. I’m proficient in R, Python, C++ and SQL, and I’m currently learning Julia. Additionally, I have advanced knowledge of Excel and intermediate skills in power BI.\nThroughout my experiences, I’ve developed a wide range of hard and soft skills. One of the most important, to me, is the ability to communicate data and findings effectively to people of all ages and backgrounds. I’ve also worked on several projects involving machine learning, AI, and statistical data analysis, where I’ve learned how to collaborate with background diverse teams and find ways to make it work.\nIn addition to all of this, I’m a big fan of history, geography, and literature. I can play many instruments (Brazilian viola is my favorite) and could talk about the Roman Empire for hours. I’m also a huge fan of Dune, The Lord of the Rings, and romantic poetry. On the left is a photo of me, happy to be meeting my nearly-namesake, Julius Caesar, in Uruguay."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Admir C. de O. Junior",
    "section": "",
    "text": "Hello, nice to meet you!\nI’m a biologist and mathematician with skills in statistics, data science and programming.\nAcademically, I’m mostly interested in all aspects of ecological modeling—from theory to practice, and its implications.\nThis website serves as my portfolio. Here, you will find information about me, my work, and side projects.\nFeel free to reach out!"
  },
  {
    "objectID": "projects/pythagoras_grouping/index.html",
    "href": "projects/pythagoras_grouping/index.html",
    "title": "Grouping students with the help of Pythagoras",
    "section": "",
    "text": "df &lt;- data.frame(\n  student = c(\"vitor\", \"luis\", \"arthur\", \"murilo\"),\n  music  =  c(\"melodic metal\", \"vaneira\", \"rock\", \"pagode\"),\n  sports =  c(\"tennis\", \"football\", \"table tennis\", \"football\"),\n  food   =  c(\"soap\", \"churrasco\", \"beans\", \"strogonoff\")\n)\n\ndf\n\n  student         music       sports       food\n1   vitor melodic metal       tennis       soap\n2    luis       vaneira     football  churrasco\n3  arthur          rock table tennis      beans\n4  murilo        pagode     football strogonoff\n\n\nOne thing I always tell my students is that nearly everything in the world can be quantified — as long as we’re okay with the consequences of doing so. For example, let’s now transform these categorical variables into numeric ones. To do this, we need to establish a rule. Since we want to measure how different my students’ preferences are, I’ll arbitrarily define ordered sets for each category, placing the most contrasting items at opposite ends. For music, I’d say the set is: {melodic metal, rock, pagode, vaneira}. This could be interpreted as a kind of ‘Brazilian-countryness’ scale, for instance — but the key idea is that ‘melodic metal’ is more similar (and thus closer on the scale) to ‘rock’ than to ‘vaneira’. For sports, the set is: {football, tennis, table tennis}. For food, the set is: {soap, beans, strogonoff, churrasco}. Guessing the scale I had in mind for the last two sets is left as an exercise for the reader (always wanted to say that). Food is the trickiest one — but I think we can all agree that soup is very different from roast beef… or at least I hope so. Also, Vitor eating soap is a inside joke of them. Don’t ask me. I’m afraid to know. Sets defined and ordered, let’s replace the categorical values for numerical ones, in our case, it will be simply the position in the set, what is highly questionable. To do this, I will use dplyr::case_when, what is an overkill, but I want to showoff my skills.\n\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\ndf &lt;- df %&gt;% \n  mutate(\n    music = case_match(\n      music,\n      \"melodic metal\" ~ 1,\n      \"rock\" ~ 2,\n      \"pagode\" ~ 3,\n      \"vaneira\" ~ 4\n    ),\n    sports = case_match(\n      sports,\n      \"football\" ~ 1,\n      \"tennis\" ~ 2,\n      \"table tennis\" ~ 3\n    ),\n    food = case_match(\n      food,\n      \"soap\" ~ 1,\n      \"beans\" ~ 2,\n      \"strogonoff\" ~ 3,\n      \"churrasco\" ~ 4\n    )\n  )\n\nNice! Now we begin our task. Firstly, the one-dimensional distance between each student for each subject is simply the numerical difference; i.e, \\(d = |x_2 - x_1|\\), being \\(d\\) the distance, and \\(x_1\\) and \\(x_2\\) two points (students) in that dimension. Now, for two-dimensional distances, things start to get interesting. Let’s plot the points with music and food as axis:\n\nlibrary(ggplot2)\n\nggplot(data = df) +\n  geom_point(aes(x = music, y = food)) +\n  geom_text(aes(x = music, y = food, label = student), \n            hjust = -0.2, vjust = -0.2, check_overlap = TRUE)\n\n\n\n\n\n\n\n\nWell, pretty organized. I like it. In our task, the knowledge popularized by a fellow mathematician more than 2,500 years ago will come in very handy. Of course, I’m talking about Pythagoras and the Pythagorean theorem. The idea is that I can draw right triangles using each pair of points (students). For example, I can choose Vitor and Arthur, or Vitor and Luis:\n\nggplot(data = df) +\n  geom_point(aes(x = music, y = food)) +\n  geom_text(aes(x = music, y = food, label = student), \n            hjust = -0.2, vjust = -0.2, check_overlap = TRUE) +\n  annotate(\"segment\", x = 1, xend = 4, y = 1, yend = 4, color = \"purple\") +\n  annotate(\"segment\", x = 1, xend = 4, y = 1, yend = 1, color = \"green\") +\n  annotate(\"segment\", x = 4, xend = 4, y = 1, yend = 4, color = \"green\")+\n  annotate(\"segment\", x = 1, xend = 2, y = 1, yend = 2, color = \"blue\") +\n  annotate(\"segment\", x = 1, xend = 2, y = 1, yend = 1, color = \"red\") +\n  annotate(\"segment\", x = 2, xend = 2, y = 1, yend = 2, color = \"red\")\n\n\n\n\n\n\n\n\nAnd you see now that the distance between each point is the hypotenuse of that right triangle, and the catheti are the one-dimensional distances we mentioned earlier. That’s awesome, because humanity has known for at least 4,000 years now that the sum of the squares of the catheti equals the square of the hypotenuse; i.e., \\(h²=a²+b²\\), being \\(h\\) the hypotenuse and \\(a\\) and \\(b\\) the catheti. Since the hypotenuse represents the distance—known as the Euclidean distance, named after Euclid, the father of geometry—we can work with it this way:\n\\[\nh²=a²+b² \\rightarrow d²=(x_2-x_1)²+(y_2-y_1)² \\rightarrow d=\\sqrt{(x_2-x_1)²+(y_2-y_1)²}\n\\]\nSo, knowing that, we can create a function to calculate it for us:\n\ndistance &lt;- function(x1,y1,x2,y2) {\n  a &lt;- x2-x1\n  b &lt;- y2-y1\n  \n  d = sqrt((a^2)+(b^2))\n  \n  return(d)\n}\n\nTo make sure that it’s working, let’s test it with the classical example: if one cathetus equals 3 and the other equals 4, the hypotenuse should equal 5:\n\ndistance(0,0,3,4)\n\n[1] 5\n\n\nThere we go. Now we can calculate the distance between each possible pair of students. This type of information is better represented by a matrix; in our case, a 4x4 matrix:\n\ndistance_matrix &lt;- matrix(nrow=4,ncol=4)\nrow.names(distance_matrix) &lt;- colnames(distance_matrix) &lt;- unique(df$student)\ndistance_matrix\n\n       vitor luis arthur murilo\nvitor     NA   NA     NA     NA\nluis      NA   NA     NA     NA\narthur    NA   NA     NA     NA\nmurilo    NA   NA     NA     NA\n\n\nNow, let’s calculate the distances:\n\nfor (name_r in rownames(distance_matrix)) {\n  for (name_c in colnames(distance_matrix)) {\n    x1 &lt;- df[df$student==name_r,\"music\"]\n    y1 &lt;- df[df$student==name_r,\"food\"]\n    \n    x2 &lt;- df[df$student==name_c,\"music\"]\n    y2 &lt;- df[df$student==name_c,\"food\"]\n    \n    distance_matrix[name_r,name_c] &lt;- distance(x1,y1,x2,y2)\n  }\n}\n\ndistance_matrix\n\n          vitor     luis   arthur   murilo\nvitor  0.000000 4.242641 1.414214 2.828427\nluis   4.242641 0.000000 2.828427 1.414214\narthur 1.414214 2.828427 0.000000 1.414214\nmurilo 2.828427 1.414214 1.414214 0.000000\n\n\nPretty cool. Now we want to vizualise the groups formed. To do this, we need to clean the matrix a bit, formatting it to a distance matrix:\n\ndistance_matrix &lt;- as.dist(distance_matrix)\ndistance_matrix\n\n          vitor     luis   arthur\nluis   4.242641                  \narthur 1.414214 2.828427         \nmurilo 2.828427 1.414214 1.414214\n\n\nBetter. Now let’s perform a hierarchical clustering, which means we’ll see which students are closer to each other and create groups based on that.\nThis process is way too complex to implement from scratch here, like we did with the Euclidean distance, so we’ll use the classic stats::hclust() function instead:\n\nhc &lt;- hclust(distance_matrix)\nplot(hc)\n\n\n\n\n\n\n\n\nPreeety cool. But two-dimensional things are kinda lame. The real deal is n-dimensional.\nHowever, for the sake of human-possible visualizations, we’ll expand our idea to just three dimensions, using all subjects.\nLet’s visualize the points in a 3D plot:\n\nlibrary(plotly)\n\n\nAttaching package: 'plotly'\n\n\nThe following object is masked from 'package:ggplot2':\n\n    last_plot\n\n\nThe following object is masked from 'package:stats':\n\n    filter\n\n\nThe following object is masked from 'package:graphics':\n\n    layout\n\nplot_ly(df, x = ~music, y = ~food, z = ~sports,\n        type = 'scatter3d', mode = 'text+markers',\n        text = ~student, marker = list(size = 5))\n\n\n\n\n\nThe group structure seems to be the same, even in 3D. To test this, we would need to calculate the euclidean distance on this three-dimensional space for each pair of points. Turns out that the pythagorean theorem is so neat that it works with any number of dimensions. The reader can easily verify this with basic geometry, and will find the equation \\[\nd=\\sqrt{(x_2-x_1)²+(y_2-y_1)²+(z_2-z_1)²}\n\\] in which \\(d\\) is the euclidean distance, \\(x\\), \\(y\\) and \\(z\\) are the values for the two points in each dimension. Now, let’s modify our function to adapt it to three dimensions:\n\ndistance &lt;- function(x1,y1,x2,y2,z1,z2) {\n  a &lt;- x2-x1\n  b &lt;- y2-y1\n  c &lt;- z2-z1\n  \n  d = sqrt((a^2)+(b^2)+(c^2))\n  \n  return(d)\n}\n\nAnd calculate again the matrix:\n\ndistance_matrix &lt;- matrix(nrow=4,ncol=4)\nrow.names(distance_matrix) &lt;- colnames(distance_matrix) &lt;- unique(df$student)\n\nfor (name_r in rownames(distance_matrix)) {\n  for (name_c in colnames(distance_matrix)) {\n    x1 &lt;- df[df$student==name_r,\"music\"]\n    y1 &lt;- df[df$student==name_r,\"food\"]\n    z1 &lt;- df[df$student==name_r,\"sports\"]\n    \n    x2 &lt;- df[df$student==name_c,\"music\"]\n    y2 &lt;- df[df$student==name_c,\"food\"]\n    z2 &lt;- df[df$student==name_c,\"sports\"]\n    \n    distance_matrix[name_r,name_c] &lt;- distance(x1,y1,x2,y2,z1,z2)\n  }\n}\n\ndistance_matrix\n\n          vitor     luis   arthur   murilo\nvitor  0.000000 4.358899 1.732051 3.000000\nluis   4.358899 0.000000 3.464102 1.414214\narthur 1.732051 3.464102 0.000000 2.449490\nmurilo 3.000000 1.414214 2.449490 0.000000\n\n\nAnd perform a hierarchical clustering again:\n\nhc &lt;- hclust(as.dist(distance_matrix))\nplot(hc)\n\n\n\n\n\n\n\n\n… well, same results. The groups are well defined. Maybe with more dimensions, the groups would start to get more mixed.\nAnd that’s it. Sometimes, basic geometry and a bit of “magic” can solve problems without the need for complex approaches.\nOf course, this example is far too simple to be applied at a large scale. There are other techniques, like DBSCAN, Spectral Clustering, and Self-Organizing Maps, that are better suited for more complex problems or different types of data.\nBut it’s unquestionable that our fellow ancient mathematicians, who discovered the relation we now call the Pythagorean theorem, also planted a seed — a seed that grew to become one of the foundations of modern mathematics and its offspring, like machine learning and statistics.\nSo next time someone tells you that math is boring or useless, you can tell them that even grouping people by their favorite food can be done using triangles.\nGeometry isn’t just about shapes on paper — it’s about understanding the world in ways you never imagined.\nAnd hey, if a 2500-year-old idea can still help us make sense of today’s data, maybe math is kind of magical after all, right?"
  },
  {
    "objectID": "projects/dice_simulations/index.html",
    "href": "projects/dice_simulations/index.html",
    "title": "Simulating dice throws to understand how probabilities work",
    "section": "",
    "text": "In a lecture about probabilities, after many examples using dices and colored balls, one of my students challenged me to throw three dices. If the sum of the faces summed more than 12, I would have to dismiss the class or let them play cards instead of studying.\nI got intrigued about the odds of this bet. What is the probabilities of them winning this? Well, with some calculation I was able to found that the probabilities of them winning were about 25.9%, what seemed pretty high for me, given that the max sum of the three dices is 18. So, to confront my theoretical approach, I decided to construct a computational simulation of this.\nBasically, we just need to create something that simulates dice throws, what is pretty easy:\n\nimport random\n\nn_dices = 3 # number of dices\n\n# Here we roll the dices\ndice_throws = [random.randint(1, 6) for _ in range(n_dices)]\nprint(f\"Rolled: {dice_throws}\")\n\nRolled: [1, 5, 3]\n\nprint(f\"Sum: {sum(dice_throws)}\")\n\nSum: 9\n\n\nNice.\nHowever, 1 repetition does not make statistics, so we need to throw it many times if we want to test something. So, we will throw three dices five times, storing its sum in a list, just to test the ideia:\n\nimport random\n\nn_dices = 3 # number of dices\nrepetitions = 5 # number of repetitions\n\n# Here we roll the dices\nexperiment = []\nfor i in range(0, repetitions):\n  \n  dice_throws = [random.randint(1, 6) for _ in range(n_dices)]\n  dice_sum = sum(dice_throws)\n  experiment.append(dice_sum)\n  \nprint(experiment)\n\n[6, 9, 17, 13, 8]\n\n\nThis is the result of our experiment (for now). But to make it serious, we need to increase the number of repetitions. Let us make it 1000. Also, we are only interested in throws that summed &gt; 12, so lets only count those. Also, I will set a seed for the randomness generator, just for it to be reproducible:\n\nimport random\nrandom.seed(13) # set seed\n\nn_dices = 3 # number of dices\nrepetitions = 1000 # number of repetitions\n\n# Here we roll the dices\nexperiment = []\nfor i in range(0, repetitions):\n  \n  dice_throws = [random.randint(1, 6) for _ in range(n_dices)]\n  dice_sum = sum(dice_throws)\n  experiment.append(dice_sum)\n  \ngreater_than_12 = sum([n &gt; 12 for n in experiment])\nprint(greater_than_12)\n\n251\n\n\nWow, 251 of 1000 throws. It’s 25,1% of chance! Pretty close to the theoretical 25,9%… but not enough. Let us expand that. We will now include replicates, something very important in experiment designs. So, we will run the experiment 10 times, and compute the probabilities for each. We will consider our final result as the arithmetic mean of those.\nYou know what? Let’s make 100,000 repetitions… and remove the seed, to ensure it is random!\n\nimport random\nimport statistics as st\nrandom.seed(13) # set seed\n\nn_dices = 3 # number of dices\nrepetitions = 100000 # number of repetitions\nreplicates = 5\n\n# Here we roll the dices\nexperiment = []\nfor j in range(0, replicates):\n  rolls = [] \n  for i in range(0, repetitions):\n  \n    dice_throws = [random.randint(1, 6) for _ in range(n_dices)]\n    dice_sum = sum(dice_throws)\n    rolls.append(dice_sum)\n  \n  greater_than_12 = sum([n &gt; 12 for n in rolls])\n  prob = greater_than_12/repetitions\n    \n  experiment.append(prob)\n\nprint(st.mean(experiment))\n\n0.259412\n\n\nWow, 25.9412%. Pretty close, huh?\nProbabilities are amazing."
  },
  {
    "objectID": "projects.html",
    "href": "projects.html",
    "title": "Projects",
    "section": "",
    "text": "Grouping students with the help of Pythagoras\n\n\n\nmath\n\n\nstatistics\n\n\nR\n\n\n\n\n\n\n\nAdmir Junior\n\n\nOct 4, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSimulating dice throws to understand how probabilities work\n\n\n\nsimulation\n\n\nstatistics\n\n\npython\n\n\n\n\n\n\n\nAdmir Junior\n\n\nDec 11, 2024\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "publications.html",
    "href": "publications.html",
    "title": "Publications",
    "section": "",
    "text": "This is an essay written back on college. It was my final work to graduate in Biological Sciences. Here I argument in favor of the inclusion of poetry as a way to teach and learn science."
  },
  {
    "objectID": "publications.html#becoming-eearth-2023",
    "href": "publications.html#becoming-eearth-2023",
    "title": "Publications",
    "section": "",
    "text": "This is an essay written back on college. It was my final work to graduate in Biological Sciences. Here I argument in favor of the inclusion of poetry as a way to teach and learn science."
  }
]